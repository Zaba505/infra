[{"body":" Context and Problem Statement As the project grows, architectural decisions are made that have long-term impacts on the system’s design, maintainability, and scalability. Without a structured way to document these decisions, we risk losing the context and rationale behind important choices, making it difficult for current and future team members to understand why certain approaches were taken.\nHow should we document architectural decisions in a way that is accessible, maintainable, and provides sufficient context for future reference?\nDecision Drivers Need for clear documentation of architectural decisions and their rationale Easy accessibility and searchability of past decisions Low barrier to entry for creating and maintaining decision records Integration with existing documentation workflow Version control friendly format Industry-standard approach that team members may already be familiar with Considered Options MADR (Markdown Architectural Decision Records) ADR using custom format Wiki-based documentation No formal ADR process Decision Outcome Chosen option: “MADR (Markdown Architectural Decision Records)”, because it provides a well-established, standardized format that is lightweight, version-controlled, and integrates seamlessly with our existing documentation structure. MADR 4.0.0 offers a clear template that captures all necessary information while remaining flexible enough for different types of decisions.\nConsequences Good, because MADR is a widely adopted standard with clear documentation and examples Good, because markdown files are easy to create, edit, and review through pull requests Good, because ADRs will be version-controlled alongside code, maintaining historical context Good, because the format is flexible enough to accommodate strategic, user-journey, and API design decisions Good, because team members can easily search and reference past decisions Neutral, because requires discipline to maintain and update ADR status as decisions evolve Bad, because team members need to learn and follow the MADR format conventions Confirmation Compliance will be confirmed through:\nCode reviews ensuring new architectural decisions are documented as ADRs ADRs are stored in docs/content/r\u0026d/adrs/ following the naming convention NNNN-title-with-dashes.md Regular reviews during architecture discussions to reference and update existing ADRs Pros and Cons of the Options MADR (Markdown Architectural Decision Records) MADR 4.0.0 is a standardized format for documenting architectural decisions using markdown.\nGood, because it’s a well-established standard with extensive documentation Good, because markdown is simple, portable, and version-control friendly Good, because it provides a clear structure while remaining flexible Good, because it integrates with static site generators and documentation tools Good, because it’s lightweight and doesn’t require special tools Neutral, because it requires some initial learning of the format Neutral, because maintaining consistency requires discipline ADR using custom format Create our own custom format for architectural decision records.\nGood, because we can tailor it exactly to our needs Bad, because it requires defining and maintaining our own standard Bad, because new team members won’t be familiar with the format Bad, because we lose the benefits of community knowledge and tooling Bad, because it may evolve inconsistently over time Wiki-based documentation Use a wiki system (like Confluence, Notion, or GitHub Wiki) to document decisions.\nGood, because wikis provide easy editing and hyperlinking Good, because some team members may be familiar with wiki tools Neutral, because it may or may not integrate with version control Bad, because content may not be version-controlled alongside code Bad, because it creates a separate system to maintain Bad, because it’s harder to review changes through standard PR process Bad, because portability and long-term accessibility may be concerns No formal ADR process Continue without a structured approach to documenting architectural decisions.\nGood, because it requires no additional overhead Bad, because context and rationale for decisions are lost over time Bad, because new team members struggle to understand why decisions were made Bad, because it leads to repeated discussions of previously settled questions Bad, because it makes it difficult to track when decisions should be revisited More Information MADR 4.0.0 specification: https://adr.github.io/madr/ ADRs will be categorized as: strategic, user-journey, or api-design ADR status values: proposed | accepted | rejected | deprecated | superseded by ADR-XXXX All ADRs are stored in docs/content/r\u0026d/adrs/ directory ","categories":"","description":"Adopt Markdown Architectural Decision Records (MADR) as the standard format for documenting architectural decisions in the project.\n","excerpt":"Adopt Markdown Architectural Decision Records (MADR) as the standard …","ref":"/infra/pr-preview/pr-589/rd/adrs/0001-use-madr-for-architecture-decision-records/","tags":"","title":"[0001] Use MADR for Architecture Decision Records"},{"body":"Components Router Ubiquiti Dream Machine Pro\nSwitch Ubiquiti 48 port PoE\nServers hp-dl360 - HP ProLiant DL360 Gen 9 CPU: 2 x Intel(R) Xeon(R) CPU E5-2620 v3 Mem: 8 x 16GB DDR4-2133 RDIMM Boot: 1 x 250GB Samsung 970 Evo Plus M.2-2280 PCIe 3.0 NVME Storage: 4 x 1TB Samsung 870 Evo Power: 2 x HP 500W Flex Slot Platinum Power Supply Accelerator: N/A camd-ryzen5 - Custom PC CPU: 1 x Ryzen 5 5600X Mem: 2 x 8GB DDR4-3600 CL19 Boot: N/A Storage: 1 x 1TB Samsung 970 Evo Plus M.2-2280 PCIe 3.0 NVME Power: 1 x EVGA SuperNOVA 750 GT 750 W 80+ Gold Accelerator: 1 x Gigabyte EAGLE Radeon RX 6700 XT 12 GB Network Topology flowchart TB router@{ label: \"Router\", shape: circle } switch@{ label: \"Switch\", shape: circle } server_a@{ label: \"hp-dl360\", shape: rect } server_b@{ label: \"hp-dl360\", shape: rect } server_c@{ label: \"camd-ryzen5\", shape: rect } subgraph one [IPMI VLAN] server_a_ipmi@{ label: \"hp-dl360 IPMI Interface\", shape: terminal } server_b_ipmi@{ label: \"hp-dl360 IPMI Interface\", shape: terminal } end subgraph two [Homelab VLAN] server_a_port2@{ label: \"hp-dl360 Port 2\", shape: terminal } server_a_port3@{ label: \"hp-dl360 Port 3\", shape: terminal } server_a_port4@{ label: \"hp-dl360 Port 4\", shape: terminal } server_b_port2@{ label: \"hp-dl360 Port 2\", shape: terminal } server_b_port3@{ label: \"hp-dl360 Port 3\", shape: terminal } server_b_port4@{ label: \"hp-dl360 Port 4\", shape: terminal } server_c_port@{ label: \"camd-ryzen5 Port\", shape: terminal } end subgraph three [Network Boot VLAN] server_a_port1@{ label: \"hp-dl360 Port 1\", shape: terminal } server_b_port1@{ label: \"hp-dl360 Port 1\", shape: terminal } end router --- switch switch --- server_a_ipmi switch --- server_a_port1 switch --- server_a_port2 switch --- server_a_port3 switch --- server_a_port4 server_a_ipmi --- server_a server_a_port1 --- server_a server_a_port2 --- server_a server_a_port3 --- server_a server_a_port4 --- server_a switch --- server_b_ipmi switch --- server_b_port1 switch --- server_b_port2 switch --- server_b_port3 switch --- server_b_port4 server_b_ipmi --- server_b server_b_port1 --- server_b server_b_port2 --- server_b server_b_port3 --- server_b server_b_port4 --- server_b switch --- server_c_port server_c_port --- server_c IPMI VLAN This VLAN groups the IPMI or IPMI-like interfaces for all servers in the homelab so that each machine can be remotely accessed. Most importantly, this access can be restricted via VLAN firewall rules.\nNetwork Boot VLAN This an exclusive VLAN for configuring the servers to network boot. This VLAN is covered in more depth on the specific Network Boot documentation.\nHomelab VLAN This is the main VLAN for servers to communicate with one another, as well as, the external internet.\n","categories":"","description":"","excerpt":"Components Router Ubiquiti Dream Machine Pro\nSwitch Ubiquiti 48 port …","ref":"/infra/pr-preview/pr-589/physical_infrastructure/","tags":"","title":"Physical Infrastructure"},{"body":"Architecture Decision Records (ADRs) This section contains architectural decision records that document the key design choices made. Each ADR follows the MADR 4.0.0 format and includes:\nContext and problem statement Decision drivers and constraints Considered options with pros and cons Decision outcome and rationale Consequences (positive and negative) Confirmation methods ADR Categories ADRs are classified into three categories:\nStrategic - High-level architectural decisions affecting the entire system (frameworks, authentication strategies, cross-cutting patterns). Use for foundational technology choices. User Journey - Decisions solving specific user journey problems. More tactical than strategic, but still architectural. Use when evaluating approaches to implement user-facing features. API Design - API endpoint implementation decisions (pagination, filtering, bulk operations). Use for significant API design trade-offs that warrant documentation. Status Values Each ADR has a status that reflects its current state:\nproposed - Decision is under consideration accepted - Decision has been approved and should be implemented rejected - Decision was considered but not approved deprecated - Decision is no longer relevant or has been superseded superseded by ADR-XXXX - Decision has been replaced by a newer ADR These records provide historical context for architectural decisions and help ensure consistency across the platform.\n","categories":"","description":"Documentation of architectural decisions made using MADR 4.0.0 standard\n","excerpt":"Documentation of architectural decisions made using MADR 4.0.0 …","ref":"/infra/pr-preview/pr-589/rd/adrs/","tags":"","title":"Architecture Decision Records"},{"body":"","categories":"","description":"","excerpt":"","ref":"/infra/pr-preview/pr-589/categories/","tags":"","title":"Categories"},{"body":" Note Network booting only applies to following machines in the homelab:\nhp-dl360 Architecture flowchart LR subgraph homelab [Homelab] server@{ label: \"Server\", shape: rect } switch@{ label: \"Switch\", shape: circle } router@{ label: \"Router\", shape: circle } end subgraph cloud [Public Cloud] wiregaurd@{ label: \"Wiregaurd\", shape: rect } matchbox@{ label: \"Matchbox\", shape: rect } end server --- switch switch --- router router --- wiregaurd wiregaurd --- matchbox Homelab Setting up Network Boot VLAN We begin by creating a VLAN on the router and assign by MAC address the first port of each server to it.\nInitializing Wiregaurd node One feature of the Router is that it can act as either a Wiregaurd server or client. In this instance, the client implementation is initialized and all traffic on the Network Boot VLAN will be assigned to go through the Wiregaurd connection.\nPublic Cloud flowchart LR gateway@{ label: \"External Passthrough Network Load Balancer\", shape: rect } subgraph k8s [Kubernetes] wiregaurd@{ label: \"Wiregaurd\", shape: rect } matchbox@{ label: \"Matchbox\", shape: rect } end gateway --- wiregaurd wiregaurd --- matchbox Within a public cloud (e.g. AWS, Azure, GCP), a Kubernetes cluster will be instantiated.\nKubernetes Architecture flowchart LR subgraph ns [Network Boot Namespace] direction LR wiregaurd_service@{ label: \"Wiregaurd Service (LoadBalancer)\", shape: rect } wiregaurd@{ label: \"Wiregaurd Daemon Set\", shape: rect } wiregaurd_config@{ label: \"Wiregaurd Config Secret\", shape: cyl } matchbox@{ label: \"Matchbox Deployment\", shape: rect } matchbox_config@{ label: \"Matchbox Config Volume\", shape: cyl } end wiregaurd_service --- wiregaurd wiregaurd --- wiregaurd_config wiregaurd --- matchbox matchbox --- matchbox_config Boot Sequence sequenceDiagram participant server as Server participant router as Router participant wiregaurd as Wiregaurd participant matchbox as Matchbox server -\u003e\u003e router: UEFI HTTP boot request router -\u003e\u003e wiregaurd: Encrypted UEFI HTTP boot request wiregaurd -\u003e\u003e matchbox: UEFI HTTP boot request matchbox -\u003e\u003e wiregaurd: UEFI Executable Image wiregaurd -\u003e\u003e router: UEFI Executable Image router -\u003e\u003e server: UEFI Executable Image ","categories":"","description":"","excerpt":" Note Network booting only applies to following machines in the …","ref":"/infra/pr-preview/pr-589/physical_infrastructure/network_boot/","tags":"","title":"Network Boot"},{"body":"","categories":"","description":"","excerpt":"","ref":"/infra/pr-preview/pr-589/rd/","tags":"","title":"Research and Development"},{"body":"","categories":"","description":"","excerpt":"","ref":"/infra/pr-preview/pr-589/tags/","tags":"","title":"Tags"},{"body":"High Level Diagram flowchart LR internet[\"Internet\"] cloudflare[\"Cloudflare\"] homelab[\"Home Lab\"] cloud[\"Public Cloud\"] internet --- cloudflare cloudflare ---|mTLS| homelab homelab ---|Wiregaurd| cloud Cloudflare Cloudflare is leveraged as both a DNS provider and HTTP(s) proxy to services hosted on the Home Lab. The primary goals of leveraging Cloudflare are the following:\nDDoS protection for all services, especially those self-hosted via the Home Lab. Home IP address hiding via proxied records aka, proxy HTTP/HTTP(s) from Internet through Cloudflare before getting to Home Lab Home Lab Any and all computer hardware primarily dedicated to self-hosting services, content, and experiments is often referred to as a home lab or home server in the context of a single server.\nPublic Cloud A public cloud provider (e.g. AWS, GCP, Azure) is used to host services needed by the Home Lab for various tasks like network booting.\n","categories":"","description":"","excerpt":"High Level Diagram flowchart LR internet[\"Internet\"] …","ref":"/infra/pr-preview/pr-589/","tags":"","title":"Zaba505's Home Lab"}]