<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical type=text/html href=https://zaba505.github.io/infra/pr-preview/pr-626/rd/analysis/resource_identification/><link rel=alternate type=application/rss+xml href=https://zaba505.github.io/infra/pr-preview/pr-626/rd/analysis/resource_identification/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/infra/pr-preview/pr-626/favicons/favicon.ico><link rel=apple-touch-icon href=/infra/pr-preview/pr-626/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/infra/pr-preview/pr-626/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/infra/pr-preview/pr-626/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/infra/pr-preview/pr-626/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/infra/pr-preview/pr-626/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/infra/pr-preview/pr-626/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/infra/pr-preview/pr-626/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/infra/pr-preview/pr-626/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/infra/pr-preview/pr-626/favicons/android-192x192.png sizes=192x192><title>Resource Identifiers Analysis | Zaba505's Home Lab</title><meta name=description content="This analysis compares three popular distributed identifier strategies for use in modern systems: UUID (particularly v4 and v7), ULID, and Snowflake ID. The comparison focuses on three critical aspects:
URI Safety: Can they be used directly in URLs without encoding? Database Performance: Storage size and index performance implications Generation Model: Centralized vs decentralized generation Quick Comparison Table Aspect UUID v4 UUID v7 ULID Snowflake ID Size (binary) 16 bytes 16 bytes 16 bytes 8 bytes Size (string) 36 chars 36 chars 26 chars 18-19 chars URI Safe âœ… Yes âœ… Yes âœ… Yes âœ… Yes Time-Ordered âŒ No âœ… Yes âœ… Yes âœ… Yes Decentralized âœ… Yes âœ… Yes âœ… Yes âš ï¸ Mostly Index Performance âš ï¸ Poor âœ… Good âœ… Good âœ… Excellent Standardized âœ… RFC 9562 âœ… RFC 9562 âŒ Spec only âŒ Pattern Database Support âœ… Native ğŸ†• Limited âŒ Custom âŒ Custom Detailed Analyses UUID Analysis ULID Analysis Snowflake ID Analysis Decision Guide Use UUID v7 when: âœ… RFC standardization is important âœ… Native database support is desired (PostgreSQL 18+) âœ… You need URN compatibility (urn:uuid:...) âœ… You want official vendor support and tooling Use ULID when: âœ… Human readability is valued (Crockford Base32) âœ… You prefer compact string representation (26 vs 36 chars) âœ… Lexicographic sorting is important âœ… You want case-insensitive identifiers Use Snowflake ID when: âœ… Storage efficiency is critical (8 vs 16 bytes) âœ… Numeric IDs are required âœ… You can manage worker ID allocation âœ… Maximum database performance is needed âœ… You have a fixed number of generator nodes (<1024) Use UUID v4 when: âœ… Maximum randomness is required âœ… Session tokens or one-time IDs âœ… Time ordering is unimportant âŒ Avoid for database primary keys Modern Recommendations (2024-2025) For new projects with database primary keys:"><meta property="og:url" content="https://zaba505.github.io/infra/pr-preview/pr-626/rd/analysis/resource_identification/"><meta property="og:site_name" content="Zaba505's Home Lab"><meta property="og:title" content="Resource Identifiers Analysis"><meta property="og:description" content="This analysis compares three popular distributed identifier strategies for use in modern systems: UUID (particularly v4 and v7), ULID, and Snowflake ID. The comparison focuses on three critical aspects:
URI Safety: Can they be used directly in URLs without encoding? Database Performance: Storage size and index performance implications Generation Model: Centralized vs decentralized generation Quick Comparison Table Aspect UUID v4 UUID v7 ULID Snowflake ID Size (binary) 16 bytes 16 bytes 16 bytes 8 bytes Size (string) 36 chars 36 chars 26 chars 18-19 chars URI Safe âœ… Yes âœ… Yes âœ… Yes âœ… Yes Time-Ordered âŒ No âœ… Yes âœ… Yes âœ… Yes Decentralized âœ… Yes âœ… Yes âœ… Yes âš ï¸ Mostly Index Performance âš ï¸ Poor âœ… Good âœ… Good âœ… Excellent Standardized âœ… RFC 9562 âœ… RFC 9562 âŒ Spec only âŒ Pattern Database Support âœ… Native ğŸ†• Limited âŒ Custom âŒ Custom Detailed Analyses UUID Analysis ULID Analysis Snowflake ID Analysis Decision Guide Use UUID v7 when: âœ… RFC standardization is important âœ… Native database support is desired (PostgreSQL 18+) âœ… You need URN compatibility (urn:uuid:...) âœ… You want official vendor support and tooling Use ULID when: âœ… Human readability is valued (Crockford Base32) âœ… You prefer compact string representation (26 vs 36 chars) âœ… Lexicographic sorting is important âœ… You want case-insensitive identifiers Use Snowflake ID when: âœ… Storage efficiency is critical (8 vs 16 bytes) âœ… Numeric IDs are required âœ… You can manage worker ID allocation âœ… Maximum database performance is needed âœ… You have a fixed number of generator nodes (<1024) Use UUID v4 when: âœ… Maximum randomness is required âœ… Session tokens or one-time IDs âœ… Time ordering is unimportant âŒ Avoid for database primary keys Modern Recommendations (2024-2025) For new projects with database primary keys:"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta itemprop=name content="Resource Identifiers Analysis"><meta itemprop=description content="This analysis compares three popular distributed identifier strategies for use in modern systems: UUID (particularly v4 and v7), ULID, and Snowflake ID. The comparison focuses on three critical aspects:
URI Safety: Can they be used directly in URLs without encoding? Database Performance: Storage size and index performance implications Generation Model: Centralized vs decentralized generation Quick Comparison Table Aspect UUID v4 UUID v7 ULID Snowflake ID Size (binary) 16 bytes 16 bytes 16 bytes 8 bytes Size (string) 36 chars 36 chars 26 chars 18-19 chars URI Safe âœ… Yes âœ… Yes âœ… Yes âœ… Yes Time-Ordered âŒ No âœ… Yes âœ… Yes âœ… Yes Decentralized âœ… Yes âœ… Yes âœ… Yes âš ï¸ Mostly Index Performance âš ï¸ Poor âœ… Good âœ… Good âœ… Excellent Standardized âœ… RFC 9562 âœ… RFC 9562 âŒ Spec only âŒ Pattern Database Support âœ… Native ğŸ†• Limited âŒ Custom âŒ Custom Detailed Analyses UUID Analysis ULID Analysis Snowflake ID Analysis Decision Guide Use UUID v7 when: âœ… RFC standardization is important âœ… Native database support is desired (PostgreSQL 18+) âœ… You need URN compatibility (urn:uuid:...) âœ… You want official vendor support and tooling Use ULID when: âœ… Human readability is valued (Crockford Base32) âœ… You prefer compact string representation (26 vs 36 chars) âœ… Lexicographic sorting is important âœ… You want case-insensitive identifiers Use Snowflake ID when: âœ… Storage efficiency is critical (8 vs 16 bytes) âœ… Numeric IDs are required âœ… You can manage worker ID allocation âœ… Maximum database performance is needed âœ… You have a fixed number of generator nodes (<1024) Use UUID v4 when: âœ… Maximum randomness is required âœ… Session tokens or one-time IDs âœ… Time ordering is unimportant âŒ Avoid for database primary keys Modern Recommendations (2024-2025) For new projects with database primary keys:"><meta itemprop=dateModified content="2025-11-24T01:56:16+00:00"><meta itemprop=wordCount content="1061"><meta name=twitter:card content="summary"><meta name=twitter:title content="Resource Identifiers Analysis"><meta name=twitter:description content="This analysis compares three popular distributed identifier strategies for use in modern systems: UUID (particularly v4 and v7), ULID, and Snowflake ID. The comparison focuses on three critical aspects:
URI Safety: Can they be used directly in URLs without encoding? Database Performance: Storage size and index performance implications Generation Model: Centralized vs decentralized generation Quick Comparison Table Aspect UUID v4 UUID v7 ULID Snowflake ID Size (binary) 16 bytes 16 bytes 16 bytes 8 bytes Size (string) 36 chars 36 chars 26 chars 18-19 chars URI Safe âœ… Yes âœ… Yes âœ… Yes âœ… Yes Time-Ordered âŒ No âœ… Yes âœ… Yes âœ… Yes Decentralized âœ… Yes âœ… Yes âœ… Yes âš ï¸ Mostly Index Performance âš ï¸ Poor âœ… Good âœ… Good âœ… Excellent Standardized âœ… RFC 9562 âœ… RFC 9562 âŒ Spec only âŒ Pattern Database Support âœ… Native ğŸ†• Limited âŒ Custom âŒ Custom Detailed Analyses UUID Analysis ULID Analysis Snowflake ID Analysis Decision Guide Use UUID v7 when: âœ… RFC standardization is important âœ… Native database support is desired (PostgreSQL 18+) âœ… You need URN compatibility (urn:uuid:...) âœ… You want official vendor support and tooling Use ULID when: âœ… Human readability is valued (Crockford Base32) âœ… You prefer compact string representation (26 vs 36 chars) âœ… Lexicographic sorting is important âœ… You want case-insensitive identifiers Use Snowflake ID when: âœ… Storage efficiency is critical (8 vs 16 bytes) âœ… Numeric IDs are required âœ… You can manage worker ID allocation âœ… Maximum database performance is needed âœ… You have a fixed number of generator nodes (<1024) Use UUID v4 when: âœ… Maximum randomness is required âœ… Session tokens or one-time IDs âœ… Time ordering is unimportant âŒ Avoid for database primary keys Modern Recommendations (2024-2025) For new projects with database primary keys:"><link rel=preload href=/infra/pr-preview/pr-626/scss/main.min.74eef40c5172b0e2f11bd9c3ea40dba66c2dc642ac5294c208f5dc9ff772c0e9.css as=style integrity="sha256-dO70DFFysOLxG9nD6kDbpmwtxkKsUpTCCPXcn/dywOk=" crossorigin=anonymous><link href=/infra/pr-preview/pr-626/scss/main.min.74eef40c5172b0e2f11bd9c3ea40dba66c2dc642ac5294c208f5dc9ff772c0e9.css rel=stylesheet integrity="sha256-dO70DFFysOLxG9nD6kDbpmwtxkKsUpTCCPXcn/dywOk=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script></head><body class=td-section><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/infra/pr-preview/pr-626/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Zaba505's Home Lab</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class="td-light-dark-menu nav-item dropdown"><svg class="d-none"><symbol id="check2" viewBox="0 0 16 16"><path d="M13.854 3.646a.5.5.0 010 .708l-7 7a.5.5.0 01-.708.0l-3.5-3.5a.5.5.0 11.708-.708L6.5 10.293l6.646-6.647a.5.5.0 01.708.0z"/></symbol><symbol id="circle-half" viewBox="0 0 16 16"><path d="M8 15A7 7 0 108 1v14zm0 1A8 8 0 118 0a8 8 0 010 16z"/></symbol><symbol id="moon-stars-fill" viewBox="0 0 16 16"><path d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/><path d="M10.794 3.148a.217.217.0 01.412.0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217.0 010 .412l-1.162.387A1.734 1.734.0 0011.593 7.69l-.387 1.162a.217.217.0 01-.412.0l-.387-1.162A1.734 1.734.0 009.31 6.593l-1.162-.387a.217.217.0 010-.412l1.162-.387a1.734 1.734.0 001.097-1.097l.387-1.162zM13.863.099a.145.145.0 01.274.0l.258.774c.115.346.386.617.732.732l.774.258a.145.145.0 010 .274l-.774.258a1.156 1.156.0 00-.732.732l-.258.774a.145.145.0 01-.274.0l-.258-.774a1.156 1.156.0 00-.732-.732l-.774-.258a.145.145.0 010-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/></symbol><symbol id="sun-fill" viewBox="0 0 16 16"><path d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></symbol></svg>
<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center" id=bd-theme type=button aria-expanded=false data-bs-toggle=dropdown data-bs-display=static aria-label="Toggle theme (auto)">
<svg class="bi my-1 theme-icon-active"><use href="#circle-half"/></svg></button><ul class="dropdown-menu dropdown-menu-end" aria-labelledby=bd-theme-text><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=light aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#sun-fill"/></svg>
Light
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center" data-bs-theme-value=dark aria-pressed=false>
<svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"/></svg>
Dark
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li><li><button type=button class="dropdown-item d-flex align-items-center active" data-bs-theme-value=auto aria-pressed=true>
<svg class="bi me-2 opacity-50"><use href="#circle-half"/></svg>
Auto
<svg class="bi ms-auto d-none"><use href="#check2"/></svg></button></li></ul></li></ul></div><div class="d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this siteâ€¦" aria-label="Search this siteâ€¦" autocomplete=off data-offline-search-index-json-src=/infra/pr-preview/pr-626/offline-search-index.9c1021abc145137555e090cfe786c049.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/infra/pr-preview/pr-626/rd/analysis/resource_identification/>Return to the regular view of this page</a>.</p></div><h1 class=title>Resource Identifiers Analysis</h1><ul><li>1: <a href=#pg-95c685912a6c8633373e2ea37cbf5347>Universally Unique Identifier (UUID) Analysis</a></li><li>2: <a href=#pg-7cb3eb798477cf3e1c5bdea6c59611a5>Universally Unique Lexicographically Sortable Identifier (ULID) Analysis</a></li><li>3: <a href=#pg-c0553e3c5388fa96911545ec8861a4bf>Snowflake ID Analysis</a></li></ul><div class=content><p>This analysis compares three popular distributed identifier strategies for use in modern systems: UUID (particularly v4 and v7), ULID, and Snowflake ID. The comparison focuses on three critical aspects:</p><ol><li><strong>URI Safety</strong>: Can they be used directly in URLs without encoding?</li><li><strong>Database Performance</strong>: Storage size and index performance implications</li><li><strong>Generation Model</strong>: Centralized vs decentralized generation</li></ol><h2 id=quick-comparison-table>Quick Comparison Table</h2><table><thead><tr><th>Aspect</th><th>UUID v4</th><th>UUID v7</th><th>ULID</th><th>Snowflake ID</th></tr></thead><tbody><tr><td><strong>Size (binary)</strong></td><td>16 bytes</td><td>16 bytes</td><td>16 bytes</td><td>8 bytes</td></tr><tr><td><strong>Size (string)</strong></td><td>36 chars</td><td>36 chars</td><td>26 chars</td><td>18-19 chars</td></tr><tr><td><strong>URI Safe</strong></td><td>âœ… Yes</td><td>âœ… Yes</td><td>âœ… Yes</td><td>âœ… Yes</td></tr><tr><td><strong>Time-Ordered</strong></td><td>âŒ No</td><td>âœ… Yes</td><td>âœ… Yes</td><td>âœ… Yes</td></tr><tr><td><strong>Decentralized</strong></td><td>âœ… Yes</td><td>âœ… Yes</td><td>âœ… Yes</td><td>âš ï¸ Mostly</td></tr><tr><td><strong>Index Performance</strong></td><td>âš ï¸ Poor</td><td>âœ… Good</td><td>âœ… Good</td><td>âœ… Excellent</td></tr><tr><td><strong>Standardized</strong></td><td>âœ… RFC 9562</td><td>âœ… RFC 9562</td><td>âŒ Spec only</td><td>âŒ Pattern</td></tr><tr><td><strong>Database Support</strong></td><td>âœ… Native</td><td>ğŸ†• Limited</td><td>âŒ Custom</td><td>âŒ Custom</td></tr></tbody></table><h2 id=detailed-analyses>Detailed Analyses</h2><ul><li><a href=uuid/>UUID Analysis</a></li><li><a href=ulid/>ULID Analysis</a></li><li><a href=snowflake/>Snowflake ID Analysis</a></li></ul><h2 id=decision-guide>Decision Guide</h2><h3 id=use-uuid-v7-when>Use UUID v7 when:</h3><ul><li>âœ… RFC standardization is important</li><li>âœ… Native database support is desired (PostgreSQL 18+)</li><li>âœ… You need URN compatibility (<code>urn:uuid:...</code>)</li><li>âœ… You want official vendor support and tooling</li></ul><h3 id=use-ulid-when>Use ULID when:</h3><ul><li>âœ… Human readability is valued (Crockford Base32)</li><li>âœ… You prefer compact string representation (26 vs 36 chars)</li><li>âœ… Lexicographic sorting is important</li><li>âœ… You want case-insensitive identifiers</li></ul><h3 id=use-snowflake-id-when>Use Snowflake ID when:</h3><ul><li>âœ… Storage efficiency is critical (8 vs 16 bytes)</li><li>âœ… Numeric IDs are required</li><li>âœ… You can manage worker ID allocation</li><li>âœ… Maximum database performance is needed</li><li>âœ… You have a fixed number of generator nodes (&lt;1024)</li></ul><h3 id=use-uuid-v4-when>Use UUID v4 when:</h3><ul><li>âœ… Maximum randomness is required</li><li>âœ… Session tokens or one-time IDs</li><li>âœ… Time ordering is unimportant</li><li>âŒ Avoid for database primary keys</li></ul><h2 id=modern-recommendations-2024-2025>Modern Recommendations (2024-2025)</h2><p><strong>For new projects with database primary keys:</strong></p><ol><li><p><strong>First choice: UUID v7 or ULID</strong></p><ul><li>Both offer excellent performance with time-ordering</li><li>UUID v7: Better standardization and tooling</li><li>ULID: Better readability and compact format</li></ul></li><li><p><strong>Storage-constrained systems: Snowflake ID</strong></p><ul><li>50% smaller than UUID/ULID</li><li>Best database performance</li><li>Requires worker ID coordination</li></ul></li><li><p><strong>Legacy compatibility: UUID v4</strong></p><ul><li>Only if required by existing systems</li><li>Significant performance penalty for databases</li></ul></li></ol><p><strong>Avoid entirely:</strong></p><ul><li>UUID v1: Privacy concerns (leaks MAC address)</li><li>UUID v6: Superseded by v7</li><li>Auto-increment integers: Not distributed-system safe</li></ul><h2 id=key-insights>Key Insights</h2><h3 id=uri-safety>URI Safety</h3><p>All three identifier types are completely safe for direct use in URIs without percent-encoding:</p><ul><li><strong>UUID</strong>: Hexadecimal + hyphens (RFC 3986 unreserved characters)</li><li><strong>ULID</strong>: Crockford Base32 alphabet (no confusing characters)</li><li><strong>Snowflake</strong>: Decimal integers (0-9 only)</li></ul><h3 id=database-performance>Database Performance</h3><p>The critical factor is <strong>sequential vs random insertion</strong>:</p><p><strong>Random insertion (UUID v4):</strong></p><ul><li>Causes B-tree page splits throughout the index</li><li>Results in fragmentation and bloat</li><li>Poor cache utilization</li><li>2-5Ã— slower than sequential</li></ul><p><strong>Sequential insertion (UUID v7, ULID, Snowflake):</strong></p><ul><li>Appends to end of B-tree</li><li>Minimal page splits</li><li>Better cache locality</li><li>Comparable to auto-increment integers</li></ul><p><strong>Storage comparison:</strong></p><pre tabindex=0><code>Snowflake ID:  8 bytes  (baseline)
UUID/ULID:    16 bytes  (2Ã— larger)
UUID string:  36 bytes  (4.5Ã— larger)
</code></pre><h3 id=generation-models>Generation Models</h3><p><strong>Fully decentralized (no coordination):</strong></p><ul><li>UUID v4: Pure randomness</li><li>UUID v7: Timestamp + randomness</li><li>ULID: Timestamp + randomness</li></ul><p><strong>Minimal coordination (worker ID only):</strong></p><ul><li>Snowflake ID: Requires unique worker ID per generator<ul><li>One-time configuration</li><li>Supports 1,024 workers (10 bits)</li><li>Challenge: Auto-scaling environments</li></ul></li></ul><h2 id=performance-benchmarks>Performance Benchmarks</h2><p>From recent studies (2024-2025):</p><p><strong>PostgreSQL INSERT operations:</strong></p><ul><li>Snowflake ID: ~34,000 ops/sec</li><li>UUID v7: ~34,000 ops/sec (33% faster than v4)</li><li>ULID: ~34,000 ops/sec (comparable to v7)</li><li>UUID v4: ~25,000 ops/sec</li></ul><p><strong>Index fragmentation (PostgreSQL):</strong></p><ul><li>UUID v4: 85% larger indexes, 54% larger tables</li><li>UUID v7/ULID: Minimal fragmentation</li><li>Snowflake: Minimal fragmentation, 50% smaller indexes</li></ul><p><strong>Write-Ahead Log (WAL) generation:</strong></p><ul><li>UUID v7: 50% reduction vs UUID v4</li><li>Sequential IDs reduce database write amplification</li></ul><h2 id=collision-resistance>Collision Resistance</h2><p>All three approaches provide exceptional collision resistance:</p><p><strong>UUID v4:</strong></p><ul><li>122 bits of randomness</li><li>Need ~2.7 Ã— 10Â¹â¸ IDs for 50% collision probability</li></ul><p><strong>UUID v7:</strong></p><ul><li>48-bit timestamp + 74-bit random</li><li>Negligible collision risk even at millions per millisecond</li></ul><p><strong>ULID:</strong></p><ul><li>48-bit timestamp + 80-bit random</li><li>1.21 Ã— 10Â²â´ unique IDs per millisecond possible</li></ul><p><strong>Snowflake ID:</strong></p><ul><li>Mathematical uniqueness guarantee</li><li>No collisions possible if worker IDs are unique</li><li>4,096 IDs per millisecond per worker</li></ul><h2 id=implementation-considerations>Implementation Considerations</h2><h3 id=postgresql>PostgreSQL</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- UUID v7 (PostgreSQL 18+)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=n>UUID</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>gen_uuid_v7</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- UUID v7 (PostgreSQL &lt;18 with extension)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=n>EXTENSION</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=n>pgcrypto</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Use custom function or library
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ULID (custom type or text/bytea)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=n>BYTEA</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>ulid_generate</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Snowflake (bigint)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>BIGINT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>snowflake_generate</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h3 id=mysql>MySQL</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- UUID (binary storage recommended)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>BINARY</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=p>(</span><span class=n>UUID_TO_BIN</span><span class=p>(</span><span class=n>UUID</span><span class=p>()))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Snowflake
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>BIGINT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h3 id=application-level-generation>Application-Level Generation</h3><p><strong>Advantages:</strong></p><ul><li>No database dependency</li><li>Works with any database</li><li>Consistent across different storage systems</li><li>Better control over implementation</li></ul><p><strong>Disadvantages:</strong></p><ul><li>Requires library/code maintenance</li><li>Clock synchronization considerations</li><li>Worker ID management (Snowflake only)</li></ul><h2 id=migration-strategies>Migration Strategies</h2><h3 id=moving-from-auto-increment>Moving from Auto-Increment</h3><p><strong>Considerations:</strong></p><ul><li>Foreign key updates required</li><li>Index rebuilds may be needed</li><li>Application code changes</li><li>Dual-write period during migration</li></ul><p><strong>Recommended approach:</strong></p><ol><li>Add new ID column alongside existing</li><li>Generate IDs for existing rows</li><li>Update foreign keys progressively</li><li>Migrate application code</li><li>Remove old ID column</li></ol><h3 id=moving-from-uuid-v4-to-v7ulid>Moving from UUID v4 to v7/ULID</h3><p><strong>Benefits:</strong></p><ul><li>Same storage size (16 bytes)</li><li>Can keep existing IDs</li><li>Only new records use v7/ULID</li><li>Gradual performance improvement</li></ul><h2 id=security-considerations>Security Considerations</h2><h3 id=information-leakage>Information Leakage</h3><p><strong>UUID v4:</strong></p><ul><li>âœ… Reveals nothing (pure randomness)</li></ul><p><strong>UUID v7 / ULID:</strong></p><ul><li>âš ï¸ Reveals creation timestamp (usually acceptable)</li><li>âš ï¸ May reveal approximate volume (via sequence patterns)</li></ul><p><strong>Snowflake ID:</strong></p><ul><li>âš ï¸ Reveals exact creation time (41-bit timestamp)</li><li>âš ï¸ Reveals which worker generated it</li><li>âš ï¸ Reveals sequence count within millisecond</li></ul><h3 id=enumeration-attacks>Enumeration Attacks</h3><p><strong>Random IDs (UUID v4):</strong></p><ul><li>âœ… Resistant to enumeration</li><li>Guessing next ID is infeasible</li></ul><p><strong>Sequential IDs (v7, ULID, Snowflake):</strong></p><ul><li>âš ï¸ Predictable patterns</li><li>Can estimate next ID value</li><li><strong>Mitigation</strong>: Use authentication/authorization, don&rsquo;t rely on ID secrecy</li></ul><h3 id=recommendation>Recommendation</h3><p>Never rely on ID unpredictability as a security mechanism. Always use proper authentication and authorization regardless of ID type.</p><h2 id=conclusion>Conclusion</h2><p>The landscape of distributed identifiers has evolved significantly:</p><p><strong>2010-2020:</strong> UUID v4 was the default distributed identifier despite performance issues</p><p><strong>2020-2024:</strong> Community alternatives (ULID, Snowflake) gained popularity for performance</p><p><strong>2024+:</strong> UUID v7 (RFC 9562) provides standardized time-ordered IDs with vendor support</p><p>For most modern applications, <strong>UUID v7 or ULID</strong> represent the optimal balance of performance, standardization, and operational simplicity. <strong>Snowflake IDs</strong> remain compelling for storage-constrained systems where the 8-byte size and numeric format provide tangible benefits.</p><p>The days of suffering UUID v4&rsquo;s random insertion penalty for database primary keys are overâ€”time-ordered identifiers are now the recommended default.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-95c685912a6c8633373e2ea37cbf5347>1 - Universally Unique Identifier (UUID) Analysis</h1><h2 id=overview>Overview</h2><p>UUIDs are 128-bit identifiers standardized in RFC 9562 (May 2024), which obsoletes the previous RFC 4122. The latest specification introduces three new versions (v6, v7, v8) while maintaining backward compatibility with existing versions.</p><h2 id=uri-safety>URI Safety</h2><h3 id=-fully-uri-safe>âœ… Fully URI-Safe</h3><p>UUIDs are inherently safe for use in URIs without any encoding required.</p><p><strong>Standard format:</strong></p><pre tabindex=0><code>550e8400-e29b-41d4-a716-446655440000
</code></pre><p><strong>Characteristics:</strong></p><ul><li>36 characters: 32 hexadecimal digits + 4 hyphens</li><li>Character set: <code>a-f</code>, <code>0-9</code>, <code>-</code></li><li>All characters are in RFC 3986 Â§2.3 unreserved set</li><li>Case-insensitive (lowercase recommended per RFC 9562)</li></ul><p><strong>Usage in URIs:</strong></p><pre tabindex=0><code>/api/users/550e8400-e29b-41d4-a716-446655440000
?id=550e8400-e29b-41d4-a716-446655440000
urn:uuid:550e8400-e29b-41d4-a716-446655440000
</code></pre><p><strong>Alternative encodings:</strong></p><ul><li>Base64 URL-safe: 22 characters (optimization, not required)</li><li>Base62: Similar length, avoids <code>+</code> and <code>/</code></li><li>These are for compactness, not safety</li></ul><h2 id=database-storage-and-performance>Database Storage and Performance</h2><h3 id=storage-size>Storage Size</h3><p><strong>Binary format:</strong></p><ul><li><strong>16 bytes (128 bits)</strong> - canonical storage format</li><li>Defined in RFC 9562</li></ul><p><strong>String format:</strong></p><ul><li>36 characters (<code>CHAR(36)</code>)</li><li>Actual storage: 36-40 bytes depending on database encoding</li></ul><p><strong>Storage comparison:</strong></p><table><thead><tr><th>Format</th><th>Size</th><th>Overhead</th></tr></thead><tbody><tr><td>Binary (<code>BINARY(16)</code>)</td><td>16 bytes</td><td>baseline</td></tr><tr><td>String (<code>CHAR(36)</code>)</td><td>36 bytes</td><td>2.25Ã—</td></tr><tr><td>String (<code>VARCHAR(36)</code>)</td><td>38-40 bytes</td><td>~2.5Ã—</td></tr></tbody></table><h3 id=database-specific-implementations>Database-Specific Implementations</h3><p><strong>PostgreSQL:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- Use native UUID type (16 bytes internally)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=n>UUID</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>gen_random_uuid</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- PostgreSQL 18+ supports UUIDv7
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>posts</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=n>UUID</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>gen_uuid_v7</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p><strong>Performance impact:</strong></p><ul><li>Native <code>UUID</code> type: 16 bytes</li><li>Text storage: Tables 54% larger, indexes 85% larger</li></ul><p><strong>MySQL:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- Use BINARY(16) with conversion functions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>BINARY</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=p>(</span><span class=n>UUID_TO_BIN</span><span class=p>(</span><span class=n>UUID</span><span class=p>()))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Retrieve with conversion
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=n>BIN_TO_UUID</span><span class=p>(</span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>users</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>SQL Server:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=n>UNIQUEIDENTIFIER</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>NEWSEQUENTIALID</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ul><li>Note: <code>NEWSEQUENTIALID()</code> generates sequential UUIDs, not <code>NEWID()</code> which is random</li></ul><h3 id=index-performance>Index Performance</h3><h4 id=the-uuid-v4-problem>The UUID v4 Problem</h4><p><strong>Random insertion issues:</strong></p><ol><li><strong>Page splits:</strong> New UUIDs insert at arbitrary positions in B-tree</li><li><strong>Fragmentation:</strong> Index becomes scattered across non-contiguous pages</li><li><strong>Wasted space:</strong> Page splits leave gaps throughout index</li><li><strong>Cache inefficiency:</strong> Poor locality leads to more cache misses</li><li><strong>Write amplification:</strong> More disk I/O per insert</li></ol><p><strong>Measured impact:</strong></p><ul><li>Constant page splits during INSERT operations</li><li>Index bloat (more pages for same data)</li><li>2-5Ã— slower than sequential IDs</li><li>Degraded SELECT performance</li></ul><h4 id=the-uuid-v7-solution>The UUID v7 Solution</h4><p><strong>Sequential insertion benefits:</strong></p><ol><li><strong>Append-only writes:</strong> New entries go to end of index</li><li><strong>Minimal page splits:</strong> Only last page splits when full</li><li><strong>Low fragmentation:</strong> Index remains mostly contiguous</li><li><strong>Better caching:</strong> Sequential access patterns</li><li><strong>Reduced I/O:</strong> Fewer disk operations</li></ol><p><strong>Measured improvements:</strong></p><ul><li>2-5Ã— faster insert performance vs v4</li><li>50% reduction in Write-Ahead Log (WAL) rate</li><li>Fewer page splits comparable to auto-increment</li><li>Better storage efficiency</li></ul><h3 id=binary-vs-string-storage>Binary vs String Storage</h3><p><strong>Index size comparison (PostgreSQL):</strong></p><table><thead><tr><th>Storage Type</th><th>Table Size</th><th>Index Size</th></tr></thead><tbody><tr><td>Binary (UUID)</td><td>100% (baseline)</td><td>100% (baseline)</td></tr><tr><td>String (TEXT)</td><td>154%</td><td>185%</td></tr></tbody></table><p><strong>Why binary is faster:</strong></p><ul><li>Smaller indexes (fewer pages)</li><li>Better cache utilization</li><li>Faster CPU comparisons (128-bit integers)</li><li>Reduced I/O (less data transfer)</li></ul><h2 id=generation-approach>Generation Approach</h2><h3 id=-fully-decentralized>âœ… Fully Decentralized</h3><p>One of UUID&rsquo;s core design goals is <strong>decentralized generation without coordination</strong>. Multiple systems can generate UUIDs independently without collision risk.</p><h3 id=uuid-version-comparison>UUID Version Comparison</h3><h4 id=uuid-v1---time-based--mac-address>UUID v1 - Time-based + MAC Address</h4><p><strong>Structure:</strong></p><pre tabindex=0><code>Timestamp (60 bits) + Clock Sequence (14 bits) + MAC Address (48 bits)
</code></pre><p><strong>Generation:</strong></p><ul><li>Timestamp: 100-nanosecond intervals since Oct 15, 1582</li><li>Node ID: System&rsquo;s MAC address</li><li>Clock sequence: Random value to prevent duplicates</li></ul><p><strong>Pros:</strong></p><ul><li>Sequential (sorts chronologically)</li><li>Very low collision risk</li><li>Decentralized</li></ul><p><strong>Cons:</strong></p><ul><li>âŒ <strong>Privacy concern:</strong> Leaks MAC address (physical location)</li><li>âŒ Timestamp not in sortable byte order</li><li>âŒ Modern systems avoid for security reasons</li></ul><p><strong>Use case:</strong> Legacy systems only (prefer v7)</p><h4 id=uuid-v4---random>UUID v4 - Random</h4><p><strong>Structure:</strong></p><pre tabindex=0><code>122 random bits + 6 version/variant bits
</code></pre><p><strong>Generation:</strong></p><ul><li>Entirely random (cryptographically secure RNG recommended)</li><li>No coordination needed</li><li>No sequential ordering</li></ul><p><strong>Pros:</strong></p><ul><li>âœ… Maximum privacy (no identifying information)</li><li>âœ… Simplest to generate</li><li>âœ… Works offline</li><li>âœ… Truly decentralized</li></ul><p><strong>Cons:</strong></p><ul><li>âŒ <strong>Poor database performance:</strong> Random insertion causes fragmentation</li><li>âŒ No time information</li><li>âŒ Higher collision probability (still astronomically low)</li></ul><p><strong>Collision probability:</strong></p><ul><li>122 bits of entropy</li><li>Need ~2.7 Ã— 10Â¹â¸ UUIDs for 50% collision chance</li><li>In practice: negligible</li></ul><p><strong>Use cases:</strong></p><ul><li>Session IDs</li><li>One-time tokens</li><li>Non-database identifiers</li><li>When pure randomness is desired</li></ul><h4 id=uuid-v6---reordered-time-based>UUID v6 - Reordered Time-based</h4><p><strong>Structure:</strong></p><pre tabindex=0><code>Timestamp (60 bits, big-endian) + Clock Sequence + Node ID
</code></pre><p><strong>Generation:</strong></p><ul><li>Like v1 but timestamp bytes reordered for sorting</li><li>Maintains MAC address (privacy concern)</li></ul><p><strong>Pros:</strong></p><ul><li>Sortable (better than v1)</li><li>Sequential insertion performance</li></ul><p><strong>Cons:</strong></p><ul><li>âŒ Still leaks MAC address</li><li>âŒ <strong>Superseded by v7:</strong> RFC 9562 recommends v7</li></ul><p><strong>Use case:</strong> None - v7 is better</p><h4 id=uuid-v7---time-ordered--random--recommended>UUID v7 - Time-ordered + Random â­ RECOMMENDED</h4><p><strong>Structure:</strong></p><pre tabindex=0><code>Unix Timestamp (48 bits, millisecond) + Random (74 bits)
</code></pre><p><strong>Generation:</strong></p><ul><li>Top 48 bits: Unix epoch milliseconds</li><li>Bottom 74 bits: Random data</li><li>No MAC address</li><li>Monotonically increasing</li></ul><p><strong>Pros:</strong></p><ul><li>âœ… <strong>Excellent database performance:</strong> Sequential inserts</li><li>âœ… <strong>Privacy-preserving:</strong> No MAC address</li><li>âœ… <strong>Sortable:</strong> Natural time ordering</li><li>âœ… <strong>Decentralized:</strong> No coordination needed</li><li>âœ… <strong>Random component:</strong> Prevents collisions from multiple nodes</li></ul><p><strong>Performance measured:</strong></p><ul><li>2-5Ã— faster inserts than v4</li><li>50% reduction in WAL rate</li><li>Minimal page splits</li><li>Better cache locality</li></ul><p><strong>Cons:</strong></p><ul><li>âš ï¸ Exposes creation timestamp (usually acceptable)</li><li>Slightly more complex than v4</li></ul><p><strong>Use cases:</strong></p><ul><li><strong>Database primary keys</strong> (optimal choice)</li><li>Distributed systems</li><li>Event IDs with time ordering</li><li>Modern applications (default recommendation)</li></ul><h3 id=decentralization-requirements>Decentralization Requirements</h3><p><strong>No central service required for any version:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Example: Independent generation</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Node A</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>uuid1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>uuid</span><span class=p>.</span><span class=nf>NewV7</span><span class=p>()</span><span class=w> </span><span class=c1>// 0191e1a6-8b2c-7890-abcd-123456789abc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Node B (same time)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>uuid2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>uuid</span><span class=p>.</span><span class=nf>NewV7</span><span class=p>()</span><span class=w> </span><span class=c1>// 0191e1a6-8b2c-7890-xyz1-987654321def</span><span class=w>
</span></span></span></code></pre></div><p><strong>How v7 avoids collisions:</strong></p><ol><li><strong>Time component:</strong> Millisecond precision provides separation</li><li><strong>Random component:</strong> 74 bits prevents same-millisecond collisions</li><li><strong>No coordination:</strong> Each node generates independently</li></ol><p><strong>Collision risk (UUID v7):</strong></p><ul><li>Within same millisecond: 2â·â´ unique values possible</li><li>Even at 1 billion IDs per millisecond: negligible collision risk</li></ul><h2 id=version-selection-guide>Version Selection Guide</h2><pre tabindex=0><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Which UUID Version?                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Database Primary Key? â”€â”€YESâ”€â”€&gt; UUID v7            â”‚
â”‚         â”‚                                            â”‚
â”‚         NO                                           â”‚
â”‚         â”‚                                            â”‚
â”‚  Need time ordering? â”€â”€YESâ”€â”€&gt; UUID v7              â”‚
â”‚         â”‚                                            â”‚
â”‚         NO                                           â”‚
â”‚         â”‚                                            â”‚
â”‚  Need pure randomness? â”€â”€YESâ”€â”€&gt; UUID v4            â”‚
â”‚                                                      â”‚
â”‚  âŒ Avoid: v1 (privacy), v6 (superseded)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><h2 id=go-library-support>Go Library Support</h2><h3 id=-official-google-uuid-library>âœ… Official Google UUID Library</h3><p>The most widely-used Go library for UUIDs is <a href=https://github.com/google/uuid><code>github.com/google/uuid</code></a>, which provides full support for UUID versions 1, 3, 4, 5, 6, and 7.</p><p><strong>Installation:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go get github.com/google/uuid
</span></span></code></pre></div><p><strong>Usage examples:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=s>&#34;github.com/google/uuid&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Generate UUID v4 (random)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>id</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>uuid</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>id</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span><span class=w> </span><span class=c1>// e.g., 550e8400-e29b-41d4-a716-446655440000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Generate UUID v7 (time-ordered, recommended for databases)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>id</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>uuid</span><span class=p>.</span><span class=nf>Must</span><span class=p>(</span><span class=nx>uuid</span><span class=p>.</span><span class=nf>NewV7</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>id</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span><span class=w> </span><span class=c1>// e.g., 0191e1a6-8b2c-7890-abcd-123456789abc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Parse existing UUID</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>parsed</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>uuid</span><span class=p>.</span><span class=nf>Parse</span><span class=p>(</span><span class=s>&#34;550e8400-e29b-41d4-a716-446655440000&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=modern-recommendations-2024-2025>Modern Recommendations (2024-2025)</h2><p><strong>For new projects:</strong></p><ol><li><p><strong>Default choice: UUID v7</strong></p><ul><li>Best performance</li><li>Decentralized generation</li><li>No privacy concerns</li><li>Sortable</li></ul></li><li><p><strong>Special cases: UUID v4</strong></p><ul><li>Explicit randomness needed</li><li>Non-database contexts</li><li>Legacy compatibility</li></ul></li><li><p><strong>Avoid: v1, v6</strong></p><ul><li>v1: Privacy issues (MAC address)</li><li>v6: v7 is better in every way</li></ul></li></ol><h2 id=recent-developments>Recent Developments</h2><h3 id=rfc-9562-may-2024>RFC 9562 (May 2024)</h3><ul><li>Obsoletes RFC 4122</li><li>Introduces v6, v7, v8</li><li>Recommends v7 for database keys</li></ul><h3 id=postgresql-18-2025>PostgreSQL 18 (2025)</h3><ul><li>Native <code>gen_uuid_v7()</code> function</li><li>Solves B-tree fragmentation</li><li>Built-in time-ordered UUID generation</li></ul><h3 id=industry-adoption>Industry Adoption</h3><ul><li>Buildkite: &ldquo;Goodbye to sequential integers, hello UUIDv7&rdquo;</li><li>Cloud providers adding native support</li><li>Database vendors implementing optimizations</li></ul><h2 id=summary>Summary</h2><table><thead><tr><th>Aspect</th><th>UUID v4</th><th>UUID v7</th></tr></thead><tbody><tr><td><strong>Storage</strong></td><td>16 bytes binary</td><td>16 bytes binary</td></tr><tr><td><strong>Generation</strong></td><td>Fully random</td><td>Time + random</td></tr><tr><td><strong>Decentralized</strong></td><td>âœ… Yes</td><td>âœ… Yes</td></tr><tr><td><strong>Coordination</strong></td><td>âŒ No</td><td>âŒ No</td></tr><tr><td><strong>URI safe</strong></td><td>âœ… Yes</td><td>âœ… Yes</td></tr><tr><td><strong>DB inserts</strong></td><td>âš ï¸ Slow (random)</td><td>âœ… Fast (sequential)</td></tr><tr><td><strong>Fragmentation</strong></td><td>âš ï¸ High</td><td>âœ… Low</td></tr><tr><td><strong>Page splits</strong></td><td>âš ï¸ Frequent</td><td>âœ… Minimal</td></tr><tr><td><strong>Sortable</strong></td><td>âŒ No</td><td>âœ… Yes (by time)</td></tr><tr><td><strong>Privacy</strong></td><td>âœ… Maximum</td><td>âœ… Good</td></tr><tr><td><strong>Best for</strong></td><td>Tokens, session IDs</td><td>Database keys</td></tr></tbody></table><h2 id=key-takeaways>Key Takeaways</h2><ol><li><strong>Always use binary storage</strong> in databases (16 bytes vs 36-40 bytes)</li><li><strong>UUID v7 is the modern default</strong> for database primary keys</li><li><strong>UUID v4 still useful</strong> for session tokens and random IDs</li><li><strong>No coordination required</strong> - all versions are fully decentralized</li><li><strong>URI-safe by design</strong> - use directly in URLs without encoding</li><li><strong>RFC standardized</strong> - wide vendor support and tooling available</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-7cb3eb798477cf3e1c5bdea6c59611a5>2 - Universally Unique Lexicographically Sortable Identifier (ULID) Analysis</h1><h2 id=overview>Overview</h2><p>ULID is a community-driven specification for unique identifiers that combine the decentralized generation of UUIDs with the performance benefits of time-ordered sequential IDs. Created as an alternative to UUID v4&rsquo;s poor database performance, ULID predates UUID v7 but shares similar design goals.</p><h2 id=uri-safety>URI Safety</h2><h3 id=-completely-uri-safe>âœ… Completely URI-Safe</h3><p>ULIDs are designed with URI usage as a primary consideration.</p><p><strong>Character set:</strong></p><ul><li>Uses Crockford&rsquo;s Base32 alphabet</li><li>Characters: <code>0123456789ABCDEFGHJKMNPQRSTVWXYZ</code></li><li>Excluded: <code>I</code>, <code>L</code>, <code>O</code>, <code>U</code> (avoid confusion and potential abuse)</li><li>32 unique characters</li></ul><p><strong>Format:</strong></p><pre tabindex=0><code>01ARZ3NDEKTSV4RRFFQ69G5FAV
</code></pre><p><strong>Characteristics:</strong></p><ul><li><strong>26 characters</strong> (10 timestamp + 16 randomness)</li><li><strong>No hyphens</strong> (unlike UUID&rsquo;s 36 chars with hyphens)</li><li><strong>Case-insensitive</strong> (can be normalized)</li><li><strong>More compact</strong> than UUID string representation</li></ul><p><strong>Advantages over UUID:</strong></p><ul><li>Shorter (26 vs 36 characters)</li><li>No special characters required</li><li>More human-readable</li><li>Case-insensitive (easier to communicate verbally)</li></ul><p><strong>Usage in URIs:</strong></p><pre tabindex=0><code>/api/users/01ARZ3NDEKTSV4RRFFQ69G5FAV
?id=01ARZ3NDEKTSV4RRFFQ69G5FAV
</code></pre><h2 id=database-storage-and-performance>Database Storage and Performance</h2><h3 id=storage-size>Storage Size</h3><p><strong>Binary representation:</strong></p><ul><li><strong>128 bits = 16 bytes</strong></li><li>Same as UUID</li></ul><p><strong>String representation:</strong></p><ul><li><strong>26 characters</strong></li><li>As UTF-8 string: 26 bytes minimum</li><li>As MySQL <code>CHAR(26)</code> with <code>utf8mb4</code>: 72 bytes</li><li><strong>Recommendation:</strong> Store as binary (16 bytes) for optimal efficiency</li></ul><p><strong>Storage comparison:</strong></p><table><thead><tr><th>Format</th><th>Size</th><th>Efficiency</th></tr></thead><tbody><tr><td>Binary (<code>BYTEA</code>/<code>BINARY(16)</code>)</td><td>16 bytes</td><td>Optimal</td></tr><tr><td>String (<code>CHAR(26)</code>)</td><td>26+ bytes</td><td>1.6Ã— larger</td></tr><tr><td>UUID string (<code>CHAR(36)</code>)</td><td>36+ bytes</td><td>2.25Ã— larger</td></tr></tbody></table><h3 id=index-performance>Index Performance</h3><p>ULIDs provide <strong>significant performance advantages</strong> over random identifiers:</p><h4 id=b-tree-index-benefits>B-tree Index Benefits</h4><p><strong>Sequential insertion pattern:</strong></p><ul><li>âœ… Dramatically reduces page splits vs UUID v4</li><li>âœ… Minimizes write amplification</li><li>âœ… Improves cache utilization</li><li>âœ… Reduces I/O operations</li><li>âœ… Prevents index fragmentation and bloat</li></ul><p><strong>Recent benchmarks (PostgreSQL, 2024-2025):</strong></p><table><thead><tr><th>ID Type</th><th>Ops/Second</th><th>Latency</th><th>Index Size</th></tr></thead><tbody><tr><td>ULID (bytea)</td><td>~34,000</td><td>58 Î¼s</td><td>Baseline</td></tr><tr><td>UUID v7</td><td>~34,000</td><td>58 Î¼s</td><td>Similar</td></tr><tr><td>UUID v4</td><td>~25,000</td><td>85 Î¼s</td><td>85% larger</td></tr></tbody></table><p><strong>Key findings:</strong></p><ul><li>ULID performance comparable to or slightly better than UUID v7</li><li>33% faster than UUID v4</li><li>Significantly more stable performance (lower variance)</li></ul><h3 id=lexicographic-sorting-benefits>Lexicographic Sorting Benefits</h3><p><strong>Chronological ordering:</strong></p><ul><li>ULIDs sort lexicographically in timestamp order</li><li>No need for additional timestamp indexes</li><li>Natural time-based ordering</li></ul><p><strong>Query optimization benefits:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- Time-range queries are efficient
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>events</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>event_id</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=s1>&#39;01ARZ3NDEK000000000000000&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>AND</span><span class=w> </span><span class=n>event_id</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=s1>&#39;01ARZ3NDEKZZZZZZZZZZZZZZ&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>Advantages:</strong></p><ul><li>Efficient range queries on time-based data</li><li>Simplified debugging (IDs reveal creation time)</li><li>Better query planner optimization</li><li>Natural partitioning by time ranges</li></ul><h3 id=impact-on-page-splits-and-fragmentation>Impact on Page Splits and Fragmentation</h3><p><strong>Dramatically reduced fragmentation compared to UUID v4:</strong></p><p><strong>UUID v4 problems:</strong></p><ul><li>Excessive page splits even before pages are full</li><li>Random writes throughout B-tree structure</li><li>Index bloat increases size on disk</li><li>Temporally related rows spread across index</li></ul><p><strong>ULID advantages:</strong></p><ul><li>Inserts at end of B-tree</li><li>Minimizes splits to only last page</li><li>Sequential writes optimize for append-heavy workloads</li><li>Reduced index maintenance overhead</li></ul><p><strong>Storage efficiency:</strong></p><ul><li>Less wasted space from partial pages</li><li>More compact indexes</li><li>Better compression ratios</li><li>Lower storage costs for write-heavy applications</li></ul><h3 id=sequential-nature-and-timestamp-ordering>Sequential Nature and Timestamp Ordering</h3><p><strong>48-bit timestamp component:</strong></p><ul><li>Millisecond precision Unix timestamp</li><li>Representation until year <strong>10889 AD</strong></li><li>High-order bits ensure chronological insertion</li><li>Enables time-based partitioning strategies</li></ul><p><strong>Performance characteristics:</strong></p><ul><li>New records naturally fall at end of B-tree</li><li>Predictable insertion patterns</li><li>Optimizes for sequential writes</li><li>Reduces fragmentation over time</li></ul><h2 id=generation-approach>Generation Approach</h2><h3 id=-fully-decentralized>âœ… Fully Decentralized</h3><p>ULIDs can be generated in a completely decentralized manner with no coordination required.</p><p><strong>No centralized service needed:</strong></p><ul><li>Each system/node generates independently</li><li>Only requires system clock access</li><li>Cryptographically secure random number generator (CSPRNG)</li><li>No network coordination overhead</li></ul><h3 id=structure-timestamp--randomness>Structure: Timestamp + Randomness</h3><p><strong>128 bits total:</strong></p><pre tabindex=0><code> 01AN4Z07BY      79KA1307SR9X4MV3
|----------|    |----------------|
 Timestamp          Randomness
   48bits             80bits
</code></pre><p><strong>Timestamp component (48 bits):</strong></p><ul><li>Milliseconds since Unix epoch</li><li>First 10 characters in encoded form</li><li>Provides temporal ordering</li></ul><p><strong>Randomness component (80 bits):</strong></p><ul><li>Cryptographically secure random value</li><li>Remaining 16 characters</li><li>Ensures uniqueness within same millisecond</li></ul><p><strong>Binary encoding:</strong></p><ul><li>Most Significant Byte first (network byte order)</li><li>Each component encoded as octets</li><li>Total: 16 octets (bytes)</li></ul><h3 id=collision-resistance>Collision Resistance</h3><p><strong>Extremely high collision resistance:</strong></p><ul><li><strong>1.21 Ã— 10Â²â´ unique IDs per millisecond</strong> (2â¸â° possible values)</li><li>Collision probability is practically zero</li><li>Even in distributed systems, likelihood of collision is exceedingly low</li></ul><p><strong>Example scale:</strong></p><ul><li>Would need to generate <strong>trillions of IDs per millisecond</strong> to see collisions</li><li>Far exceeds any practical generation rate</li><li>Safe for production at any realistic scale</li></ul><h3 id=monotonicity-guarantees>Monotonicity Guarantees</h3><h4 id=standard-generation-non-monotonic>Standard Generation (Non-Monotonic)</h4><p><strong>Default behavior:</strong></p><ul><li>Each ULID uses fresh random 80 bits</li><li>Sortable by timestamp (millisecond precision)</li><li>No guarantee of order within same millisecond</li></ul><h4 id=monotonic-mode-optional>Monotonic Mode (Optional)</h4><p><strong>Algorithm:</strong></p><ol><li>If timestamp same as previous: increment previous random component</li><li>If timestamp advanced: generate fresh random component</li><li>If overflow (2â¸â° increments): wait for next millisecond or fail</li></ol><p><strong>Benefits:</strong></p><ul><li>âœ… Guarantees strict ordering even at sub-millisecond generation</li><li>âœ… Better collision resistance through sequential randomness</li><li>âœ… Maintains sortability within same timestamp</li></ul><p><strong>Trade-offs:</strong></p><ul><li>âš ï¸ Leaks information about IDs generated within same millisecond</li><li>âš ï¸ Potential security concern: enables enumeration attacks</li><li>âš ï¸ Can overflow if > 2â¸â° IDs generated in one millisecond (theoretical only)</li></ul><p><strong>Collision probability in monotonic mode:</strong></p><ul><li>Actually reduces collision risk</li><li>Incrementing creates number groups less likely to collide</li><li>Safe to use in production systems</li></ul><h2 id=comparison-to-uuid-v7>Comparison to UUID v7</h2><p>Both ULID and UUID v7 solve similar problems with different approaches:</p><table><thead><tr><th>Aspect</th><th>ULID</th><th>UUID v7</th></tr></thead><tbody><tr><td><strong>Size</strong></td><td>16 bytes</td><td>16 bytes</td></tr><tr><td><strong>Timestamp bits</strong></td><td>48</td><td>48</td></tr><tr><td><strong>Random bits</strong></td><td>80</td><td>74</td></tr><tr><td><strong>String format</strong></td><td>26 chars (Base32)</td><td>36 chars (hex + hyphens)</td></tr><tr><td><strong>Standardization</strong></td><td>Community spec</td><td>RFC 9562 (official)</td></tr><tr><td><strong>DB support</strong></td><td>Custom</td><td>Native (PostgreSQL 18+)</td></tr><tr><td><strong>Readability</strong></td><td>Better (Base32)</td><td>Standard (hex)</td></tr><tr><td><strong>Case sensitivity</strong></td><td>Insensitive</td><td>Insensitive</td></tr><tr><td><strong>Hyphens</strong></td><td>None</td><td>4 hyphens</td></tr></tbody></table><p><strong>ULID advantages:</strong></p><ul><li>More compact string representation (26 vs 36)</li><li>Slightly more random bits (80 vs 74)</li><li>Better human readability (Crockford Base32)</li><li>No hyphens (simpler to handle)</li></ul><p><strong>UUID v7 advantages:</strong></p><ul><li>Official RFC standardization</li><li>Growing native database support</li><li>URN namespace compatibility (<code>urn:uuid:...</code>)</li><li>Wider vendor tooling support</li></ul><h2 id=2024-2025-landscape>2024-2025 Landscape</h2><p><strong>Current state:</strong></p><ul><li>UUID v7 (RFC 9562, 2024) now offers similar benefits with standardization</li><li>ULID remains compelling for human readability and compact representation</li><li>Both vastly superior to UUID v4 for database performance</li><li>Choice often: standardization (v7) vs. readability (ULID)</li></ul><p><strong>Industry adoption:</strong></p><ul><li>incident.io uses ULIDs for all identifiers</li><li>Various startups prefer ULID for API design</li><li>UUID v7 gaining traction in enterprise systems</li></ul><h2 id=use-cases>Use Cases</h2><p><strong>ULIDs are excellent for:</strong></p><ul><li>âœ… Database primary keys (especially write-heavy workloads)</li><li>âœ… Distributed systems requiring decentralized ID generation</li><li>âœ… Applications needing URI-safe identifiers</li><li>âœ… Systems benefiting from time-ordered IDs</li><li>âœ… Scenarios requiring human-readable identifiers</li><li>âœ… APIs where compact IDs are valued</li></ul><p><strong>Consider alternatives when:</strong></p><ul><li>âš ï¸ Strict RFC/ISO standardization required (use UUID v7)</li><li>âš ï¸ Native database support is priority (UUID v7 has better tooling)</li><li>âš ï¸ Absolute minimal storage (auto-increment or Snowflake)</li><li>âš ï¸ High-security scenarios sensitive to timing information leakage</li></ul><h2 id=implementation-examples>Implementation Examples</h2><h3 id=postgresql>PostgreSQL</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- Store as bytea for optimal performance
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>events</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>event_id</span><span class=w> </span><span class=n>BYTEA</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>ulid_generate</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>created_at</span><span class=w> </span><span class=n>TIMESTAMPTZ</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>NOW</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>data</span><span class=w> </span><span class=n>JSONB</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Custom function needed (no native support)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>ulid_generate</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>RETURNS</span><span class=w> </span><span class=n>BYTEA</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- Implementation using pgcrypto or external library
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=mysql>MySQL</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- Store as BINARY(16)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>events</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>event_id</span><span class=w> </span><span class=nb>BINARY</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>created_at</span><span class=w> </span><span class=k>TIMESTAMP</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>data</span><span class=w> </span><span class=n>JSON</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Generate in application layer
</span></span></span></code></pre></div><h3 id=application-level-generation>Application-Level Generation</h3><p><strong>Go example:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=s>&#34;github.com/oklog/ulid/v2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Standard generation</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>id</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ulid</span><span class=p>.</span><span class=nf>Make</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>id</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span><span class=w> </span><span class=c1>// 01ARZ3NDEKTSV4RRFFQ69G5FAV</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Monotonic generation</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>entropy</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ulid</span><span class=p>.</span><span class=nf>Monotonic</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>NewSource</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>UnixNano</span><span class=p>())),</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>id</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ulid</span><span class=p>.</span><span class=nf>MustNew</span><span class=p>(</span><span class=nx>ulid</span><span class=p>.</span><span class=nf>Timestamp</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()),</span><span class=w> </span><span class=nx>entropy</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h2 id=go-library-support>Go Library Support</h2><h3 id=-oklogulid-library>âœ… oklog/ulid Library</h3><p>The canonical Go library for ULIDs is <a href=https://github.com/oklog/ulid><code>github.com/oklog/ulid/v2</code></a>, which provides full ULID specification support with both standard and monotonic generation modes.</p><p><strong>Installation:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go get github.com/oklog/ulid/v2
</span></span></code></pre></div><p><strong>Usage examples:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;crypto/rand&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;github.com/oklog/ulid/v2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Simple generation with default entropy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>id</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ulid</span><span class=p>.</span><span class=nf>Make</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>id</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span><span class=w> </span><span class=c1>// e.g., 01ARZ3NDEKTSV4RRFFQ69G5FAV</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Monotonic generation for strict ordering</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>entropy</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ulid</span><span class=p>.</span><span class=nf>Monotonic</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nx>Reader</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>id</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ulid</span><span class=p>.</span><span class=nf>MustNew</span><span class=p>(</span><span class=nx>ulid</span><span class=p>.</span><span class=nf>Timestamp</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()),</span><span class=w> </span><span class=nx>entropy</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h2 id=summary>Summary</h2><p>ULID represents an excellent choice for modern distributed systems:</p><p><strong>Key strengths:</strong></p><ol><li><strong>Fully decentralized</strong> - no coordination required</li><li><strong>URI-safe and compact</strong> - 26 characters, no special chars</li><li><strong>Excellent database performance</strong> - time-ordered, minimal fragmentation</li><li><strong>Human-readable</strong> - Crockford Base32 alphabet</li><li><strong>High collision resistance</strong> - 1.21 Ã— 10Â²â´ IDs per millisecond</li></ol><p><strong>Key considerations:</strong></p><ol><li>Not officially standardized (community spec)</li><li>Requires custom database functions (no native support)</li><li>Exposes creation timestamp (like UUID v7)</li><li>Slightly more complex than UUID v4 generation</li></ol><p><strong>Bottom line:</strong>
ULID is an excellent choice when you value compact, human-readable identifiers and don&rsquo;t require strict RFC compliance. For official standardization, UUID v7 offers similar performance with growing vendor support.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c0553e3c5388fa96911545ec8861a4bf>3 - Snowflake ID Analysis</h1><h2 id=overview>Overview</h2><p>Snowflake IDs are 64-bit unique identifiers originally developed by Twitter (now X) in 2010 to replace auto-incrementing integer IDs that became problematic as they scaled across multiple database shards. The format has been widely adopted by other distributed systems including Discord, Instagram, and many platforms requiring globally unique, time-ordered identifiers.</p><p><strong>Key differentiator:</strong> Half the size of UUIDs/ULIDs while maintaining distributed generation and time-ordering properties.</p><h2 id=uri-safety>URI Safety</h2><h3 id=-completely-uri-safe>âœ… Completely URI-Safe</h3><p>Snowflake IDs are inherently URI-safe in their native numeric form.</p><p><strong>Native format:</strong></p><ul><li>64-bit signed integer</li><li>Decimal string representation: 18-19 characters</li><li>Contains only digits: <code>0-9</code></li><li>No URL encoding required</li></ul><p><strong>Usage examples:</strong></p><pre tabindex=0><code>https://api.twitter.com/tweets/175928847299117063
https://discord.com/api/users/53908232506183680
</code></pre><h3 id=alternative-encodings>Alternative Encodings</h3><h4 id=decimal-string-recommended>Decimal String (Recommended)</h4><pre tabindex=0><code>175928847299117063
</code></pre><ul><li>Most common format (Twitter, Discord, etc.)</li><li>No encoding required</li><li>Human-readable (though not easily interpretable)</li><li>Length: 18-19 characters</li><li>Safe for both path parameters and query strings</li></ul><h4 id=base62-encoding>Base62 Encoding</h4><pre tabindex=0><code>2BisCQ
</code></pre><ul><li>Often used in URL shorteners</li><li>Compact, alphanumeric identifiers</li><li>No special characters requiring URL encoding</li><li>Length: ~11 characters</li><li>Characters: <code>[A-Za-z0-9]</code></li></ul><h4 id=base64url-encoding>Base64URL Encoding</h4><pre tabindex=0><code>AJ8CWJ-eR2Q
</code></pre><ul><li>Used by Twitter for media keys</li><li>URL-safe alphabet: <code>-</code> and <code>_</code> instead of <code>+</code> and <code>/</code></li><li>Padding (<code>=</code>) typically omitted</li><li>Length: ~11 characters</li></ul><h3 id=encoding-concerns>Encoding Concerns</h3><p><strong>None for standard numeric representation.</strong> Snowflake IDs as decimal integers naturally comply with URI specifications (RFC 3986) as unreserved characters.</p><h2 id=database-storage-and-performance>Database Storage and Performance</h2><h3 id=storage-size>Storage Size</h3><p><strong>8 bytes (64 bits)</strong> per Snowflake ID</p><p><strong>Comparison table:</strong></p><table><thead><tr><th>ID Type</th><th>Storage Size</th><th>vs Snowflake</th></tr></thead><tbody><tr><td><strong>Snowflake ID</strong></td><td>8 bytes</td><td>baseline</td></tr><tr><td>Auto-increment INT32</td><td>4 bytes</td><td>0.5Ã—</td></tr><tr><td>Auto-increment BIGINT</td><td>8 bytes</td><td>1Ã—</td></tr><tr><td>UUID/ULID (binary)</td><td>16 bytes</td><td>2Ã— larger</td></tr><tr><td>UUID (string)</td><td>36 bytes</td><td>4.5Ã— larger</td></tr></tbody></table><p><strong>Impact at scale:</strong></p><ul><li>For Twitter&rsquo;s billions of tweets, 8-byte advantage over UUIDs saves massive storage</li><li>Reduced memory footprint for indexes</li><li>Better cache utilization</li><li>Lower network transfer costs</li></ul><h3 id=index-performance>Index Performance</h3><p>Snowflake IDs provide <strong>exceptional B-tree index performance</strong> due to their time-ordered nature.</p><h4 id=sequential-insert-benefits>Sequential Insert Benefits</h4><p><strong>Optimal write performance:</strong></p><ul><li>âœ… No page splits (appends to end of index)</li><li>âœ… No expensive B-tree reorganizations</li><li>âœ… Minimal I/O (sequential writes minimize disk seeks)</li><li>âœ… Better cache utilization (hot pages remain in memory)</li></ul><h4 id=comparison-to-random-ids>Comparison to Random IDs</h4><p><strong>UUID v4 causes:</strong></p><ul><li>âŒ Random index insertions throughout tree</li><li>âŒ Frequent page splits and reorganizations</li><li>âŒ Index fragmentation</li><li>âŒ Reduced cache efficiency</li><li>âŒ Higher write amplification</li></ul><p><strong>Benchmarks:</strong></p><ul><li>Snowflake IDs: <strong>Lower mean, variance, and standard deviation</strong> for ordered operations</li><li>UUID v4: <strong>Very high variance</strong> with unstable performance</li><li>Snowflake: <strong>Significantly better</strong> for ordered queries</li></ul><h3 id=time-ordered-nature-and-benefits>Time-Ordered Nature and Benefits</h3><p>The first 41 bits represent a timestamp (milliseconds since epoch), providing natural time-ordering.</p><h4 id=query-optimization>Query Optimization</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- Time-range queries are highly efficient
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tweets</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>tweet_id</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>175928847299117063</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>AND</span><span class=w> </span><span class=n>tweet_id</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>175928847299999999</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>Benefits:</strong></p><ul><li>Database can use range scans effectively</li><li>No need for separate <code>created_at</code> timestamp indexes (in many cases)</li><li>Natural partitioning by time is straightforward</li><li>Query planner optimizations leverage time-ordering</li></ul><h4 id=sorting-benefits>Sorting Benefits</h4><ul><li>IDs are <strong>lexicographically sortable</strong> by creation time</li><li><code>ORDER BY id</code> implicitly orders by creation time</li><li>No need for separate sort operations in many scenarios</li><li>Simpler query plans</li></ul><h4 id=data-partitioning>Data Partitioning</h4><ul><li>Time-based partitioning schemes align naturally with ID ranges</li><li>Simplifies archival strategies</li><li>Facilitates efficient data retention policies</li><li>Easy to implement hot/cold data separation</li></ul><h3 id=impact-on-database-operations>Impact on Database Operations</h3><p><strong>Write operations:</strong></p><ul><li>âœ… <strong>INSERT</strong>: Exceptional performance (sequential, append-only)</li><li>âœ… <strong>Batch inserts</strong>: Highly efficient due to sequential nature</li><li>âœ… <strong>Index maintenance</strong>: Minimal overhead</li></ul><p><strong>Read operations:</strong></p><ul><li>âœ… <strong>Point queries by ID</strong>: Standard B-tree performance (O(log n))</li><li>âœ… <strong>Range queries</strong>: Excellent for time-based ranges</li><li>âœ… <strong>Ordered queries</strong>: Superior to UUID-based systems</li><li>âš ï¸ <strong>Join operations</strong>: Standard performance (64-bit integer comparison)</li></ul><p><strong>Storage:</strong></p><ul><li>âœ… <strong>Primary key</strong>: 8 bytes (optimal for 64-bit systems)</li><li>âœ… <strong>Foreign keys</strong>: 8 bytes</li><li>âœ… <strong>Index size</strong>: 50% smaller than UUID-based indexes</li><li>âœ… <strong>Memory footprint</strong>: More cache-efficient than UUIDs</li></ul><h3 id=comparison-to-other-numeric-ids>Comparison to Other Numeric IDs</h3><table><thead><tr><th>ID Type</th><th>Size</th><th>Time-Ordered</th><th>Distributed</th><th>Index Perf</th><th>Sortable by Time</th></tr></thead><tbody><tr><td><strong>Snowflake</strong></td><td>8 bytes</td><td>âœ… Yes</td><td>âœ… Yes</td><td>Excellent</td><td>âœ… Yes</td></tr><tr><td>Auto-increment</td><td>4-8 bytes</td><td>âœ… Yes</td><td>âŒ No</td><td>Excellent</td><td>âœ… Yes</td></tr><tr><td>UUID v4</td><td>16 bytes</td><td>âŒ No</td><td>âœ… Yes</td><td>Poor</td><td>âŒ No</td></tr><tr><td>UUID v7</td><td>16 bytes</td><td>âœ… Yes</td><td>âœ… Yes</td><td>Good</td><td>âœ… Yes</td></tr><tr><td>ULID</td><td>16 bytes</td><td>âœ… Yes</td><td>âœ… Yes</td><td>Good</td><td>âœ… Yes</td></tr></tbody></table><p><strong>Unique combination:</strong></p><ul><li>Distributed generation capability (like UUID)</li><li>Time-ordered properties (like auto-increment)</li><li><strong>Compact size (8 bytes)</strong></li><li>Excellent index performance</li></ul><h2 id=generation-approach>Generation Approach</h2><h3 id=-mostly-decentralized>âš ï¸ Mostly Decentralized</h3><p>Snowflake IDs can be generated in a <strong>mostly decentralized manner</strong> with minimal coordination.</p><p><strong>Key characteristics:</strong></p><ul><li>âœ… No centralized coordination during ID generation</li><li>âœ… No network calls required between generators</li><li>âœ… No database round-trips for ID allocation</li><li>âœ… High throughput: Up to 4,096 IDs per millisecond per worker</li><li>âœ… Low latency: Sub-microsecond generation time</li><li>âš ï¸ Requires one-time worker ID allocation</li></ul><h3 id=structure-breakdown>Structure Breakdown</h3><p>A Snowflake ID is a <strong>63-bit signed integer</strong> (within 64-bit type):</p><pre tabindex=0><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Timestamp (41 bits)            â”‚ Worker (10)  â”‚ Sequence (12)|
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 â† Most Significant                                  Least Significant â†’
</code></pre><h4 id=1-timestamp-component-41-bits>1. Timestamp Component (41 bits)</h4><p><strong>Purpose:</strong> Milliseconds since custom epoch</p><p><strong>Characteristics:</strong></p><ul><li>Range: ~69 years of unique timestamps</li><li>Epoch: Configurable (Twitter: 1288834974657, Discord: 1420070400000)</li><li>Most significant bits ensure chronological sorting</li><li>Enables time-range queries</li></ul><p><strong>Benefits:</strong></p><ul><li>Provides time-ordering</li><li>Natural partitioning by time</li><li>Debugging aid (can decode timestamp)</li></ul><h4 id=2-workermachine-id-10-bits>2. Worker/Machine ID (10 bits)</h4><p><strong>Purpose:</strong> Identifies the generator node</p><p><strong>Characteristics:</strong></p><ul><li>Range: 0-1023 (1,024 unique workers)</li><li>Often split further:<ul><li><strong>Twitter original</strong>: 5-bit datacenter ID + 5-bit worker ID</li><li><strong>Discord</strong>: 5-bit worker ID + 5-bit process ID</li><li><strong>Custom</strong>: Can be adapted to organizational needs</li></ul></li></ul><p><strong>Critical requirement:</strong> Each worker MUST have a unique ID</p><h4 id=3-sequence-number-12-bits>3. Sequence Number (12 bits)</h4><p><strong>Purpose:</strong> Counter for IDs generated in same millisecond</p><p><strong>Characteristics:</strong></p><ul><li>Range: 0-4095 (4,096 IDs per millisecond per worker)</li><li>Increments for each ID within the same millisecond</li><li>Resets to 0 when millisecond changes</li><li><strong>If exhausted</strong>: Generator waits until next millisecond</li></ul><p><strong>System-wide capacity:</strong></p><ul><li>Per worker: 4,096,000 IDs per second</li><li>With 1,024 workers: ~4.2 billion IDs per second theoretical maximum</li></ul><h3 id=centralized-coordination-requirements>Centralized Coordination Requirements</h3><p><strong>Minimal coordination required, but only during initial setup:</strong></p><h4 id=what-requires-coordination-one-time>What Requires Coordination (One-Time):</h4><ol><li>âœ… <strong>Worker ID allocation</strong> (during node provisioning)</li><li>âœ… <strong>Epoch selection</strong> (at system design time)</li><li>âš ï¸ <strong>Clock synchronization</strong> (ongoing, but not critical)</li></ol><h4 id=what-does-not-require-coordination>What Does NOT Require Coordination:</h4><ul><li>âŒ Individual ID generation</li><li>âŒ Real-time communication between nodes</li><li>âŒ Distributed locks or consensus</li><li>âŒ Database queries for next ID</li></ul><h3 id=worker-id-allocation-requirements>Worker ID Allocation Requirements</h3><p><strong>This is the primary coordination challenge in Snowflake ID systems.</strong></p><h4 id=static-allocation-simple>Static Allocation (Simple)</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># Configuration file</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>servers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>server-1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>worker_id</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>server-2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>worker_id</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>server-3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>worker_id</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span></code></pre></div><p><strong>Pros:</strong></p><ul><li>âœ… Simple to implement</li><li>âœ… No runtime coordination</li><li>âœ… Predictable and debuggable</li></ul><p><strong>Cons:</strong></p><ul><li>âŒ Doesn&rsquo;t work with auto-scaling</li><li>âŒ Manual reconfiguration needed</li><li>âŒ Worker ID exhaustion in large deployments</li></ul><h4 id=dynamic-allocation-complex>Dynamic Allocation (Complex)</h4><p><strong>Common strategies for dynamic environments:</strong></p><p><strong>1. Zookeeper/etcd Coordination</strong></p><pre tabindex=0><code>- Nodes register and receive unique worker IDs
- Lease-based assignment with TTL
- Automatic reclamation of dead workers
</code></pre><ul><li>âœ… Automatic worker ID management</li><li>âŒ Requires external coordination service</li><li>âŒ Added operational complexity</li></ul><p><strong>2. Database-Based Registry</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>worker_registry</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>worker_id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>instance_id</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>255</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>last_heartbeat</span><span class=w> </span><span class=k>TIMESTAMP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ul><li>âœ… No additional infrastructure</li><li>âŒ Database dependency</li><li>âŒ Requires heartbeat mechanism</li></ul><p><strong>3. Consistent Hashing</strong></p><pre tabindex=0><code>worker_id = hash(node_ip_or_mac) % 1024
</code></pre><ul><li>âœ… No coordination needed</li><li>âŒ Risk of collisions in large clusters</li><li>âŒ Requires careful hash function selection</li></ul><p><strong>4. Container Orchestration Integration</strong></p><pre tabindex=0><code>- Kubernetes StatefulSets with ordinal indexes
- Cloud provider instance metadata
- Environment variable injection
</code></pre><ul><li>âœ… Integrates with existing infrastructure</li><li>âŒ Platform-specific</li><li>âŒ May limit to 1,024 pods/instances</li></ul><p><strong>Challenge in auto-scaling:</strong></p><blockquote><p>&ldquo;In a dynamic environment with auto-scaling, managing worker IDs becomes challenging. You need a strategy to assign unique worker IDs to new instances.&rdquo;</p></blockquote><h3 id=collision-avoidance-mechanisms>Collision Avoidance Mechanisms</h3><p>Snowflake IDs guarantee uniqueness through multiple layers:</p><h4 id=1-temporal-uniqueness>1. Temporal Uniqueness</h4><ul><li>41-bit timestamp ensures different milliseconds get different IDs</li><li>System clock monotonicity prevents duplicate timestamps</li></ul><h4 id=2-spatial-uniqueness>2. Spatial Uniqueness</h4><ul><li>10-bit worker ID ensures different nodes generate different IDs</li><li><strong>Critical requirement:</strong> Each worker MUST have a unique ID</li></ul><h4 id=3-sequential-uniqueness>3. Sequential Uniqueness</h4><ul><li>12-bit sequence counter within same millisecond</li><li>Allows up to 4,096 IDs per worker per millisecond</li></ul><h4 id=mathematical-guarantee>Mathematical Guarantee</h4><pre tabindex=0><code>Unique ID = f(timestamp, worker_id, sequence)
</code></pre><p><strong>As long as:</strong></p><ul><li><code>worker_id</code> is unique per node (most critical)</li><li>Clock doesn&rsquo;t move backwards significantly</li><li>Sequence doesn&rsquo;t overflow (wait 1ms if it does)</li></ul><p><strong>Then collisions are mathematically impossible.</strong></p><h3 id=collision-risk-scenarios>Collision Risk Scenarios</h3><p><strong>Very Low Risk:</strong></p><ul><li>âš ï¸ Clock skew between nodes (IDs remain unique, may not be perfectly ordered)</li><li>âš ï¸ Leap second handling (typically managed by NTP)</li></ul><p><strong>High Risk (Configuration Errors):</strong></p><ul><li>âŒ <strong>Duplicate worker IDs:</strong> Multiple nodes with same worker ID</li><li>âŒ <strong>Clock moving backwards:</strong> System time reset or NTP correction</li><li>âŒ <strong>Worker ID overflow:</strong> Attempting to use more than 1,024 workers</li></ul><h3 id=generation-rate-limits>Generation Rate Limits</h3><p><strong>Per worker:</strong></p><ul><li>Maximum: 4,096 IDs per millisecond</li><li>Per second: 4,096,000 IDs per worker</li><li>Typical usage: Far below maximum in most applications</li></ul><p><strong>Handling exhaustion:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Pseudocode</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=nx>sequence</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>4096</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Wait until next millisecond</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>waitUntil</span><span class=p>(</span><span class=nx>nextMillisecond</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>sequence</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=implementation-considerations>Implementation Considerations</h2><h3 id=advantages>Advantages</h3><ul><li>âœ… <strong>No single point of failure</strong> (after worker ID allocation)</li><li>âœ… <strong>Minimal coordination overhead</strong></li><li>âœ… <strong>Extremely high throughput</strong></li><li>âœ… <strong>Low generation latency</strong></li><li>âœ… <strong>Natural load distribution</strong></li><li>âœ… <strong>Smallest storage size</strong> (8 bytes)</li><li>âœ… <strong>Best database performance</strong></li></ul><h3 id=disadvantages>Disadvantages</h3><ul><li>âš ï¸ <strong>Requires unique worker ID management</strong></li><li>âš ï¸ <strong>Clock synchronization needed</strong> (NTP recommended)</li><li>âš ï¸ <strong>Fixed worker limit</strong> (1,024 without redesign)</li><li>âš ï¸ <strong>Not truly random</strong> (predictable structure)</li><li>âš ï¸ <strong>Information leakage</strong> (creation time, rough volume)</li><li>âš ï¸ <strong>Auto-scaling complexity</strong> (worker ID allocation)</li></ul><h2 id=security-considerations>Security Considerations</h2><h3 id=information-leakage>Information Leakage</h3><p>Snowflake IDs reveal more information than UUIDs:</p><p><strong>What&rsquo;s exposed:</strong></p><ul><li>âš ï¸ <strong>Exact creation time</strong> (41-bit timestamp)</li><li>âš ï¸ <strong>Which worker generated it</strong> (10-bit worker ID)</li><li>âš ï¸ <strong>Sequence count</strong> within millisecond (12-bit sequence)</li></ul><p><strong>Potential concerns:</strong></p><ul><li>Business activity levels can be inferred</li><li>Worker distribution visible</li><li>Timeline of events can be reconstructed</li></ul><h3 id=enumeration-attacks>Enumeration Attacks</h3><p><strong>Predictable patterns:</strong></p><ul><li>âš ï¸ Can estimate next ID value</li><li>âš ï¸ Can enumerate recent IDs</li><li>âš ï¸ Can probe for existence of IDs in ranges</li></ul><p><strong>Mitigation:</strong></p><ul><li>âœ… Use authentication/authorization (don&rsquo;t rely on ID secrecy)</li><li>âœ… Implement rate limiting</li><li>âœ… Add additional access controls</li><li>âœ… Consider signing/encrypting IDs if necessary</li></ul><p><strong>Important:</strong> Never rely on ID unpredictability as a security mechanism.</p><h2 id=real-world-implementations>Real-World Implementations</h2><h3 id=twitter-original>Twitter (Original)</h3><pre tabindex=0><code>1 bit (unused) + 41 bits (timestamp) + 5 bits (datacenter) +
5 bits (worker) + 12 bits (sequence)
</code></pre><ul><li>Epoch: November 4, 2010, 01:42:54 UTC</li><li>32 datacenters, 32 workers per datacenter</li><li>Up to 4,096 IDs per millisecond per worker</li></ul><h3 id=discord>Discord</h3><pre tabindex=0><code>1 bit (unused) + 41 bits (timestamp) + 5 bits (worker) +
5 bits (process) + 12 bits (sequence)
</code></pre><ul><li>Epoch: January 1, 2015, 00:00:00 UTC</li><li>Allows multiple processes per worker</li><li>Custom epoch for longer lifespan</li></ul><h3 id=instagram>Instagram</h3><ul><li>Similar structure to Twitter</li><li>Sharded database architecture</li><li>Combines Snowflake with PostgreSQL sequences</li></ul><h2 id=go-library-support>Go Library Support</h2><h3 id=-bwmarrinsnowflake-library>âœ… bwmarrin/snowflake Library</h3><p>The most popular Go library for Snowflake IDs is <a href=https://github.com/bwmarrin/snowflake><code>github.com/bwmarrin/snowflake</code></a>, which provides a production-ready implementation with configurable epoch and node ID.</p><p><strong>Installation:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go get github.com/bwmarrin/snowflake
</span></span></code></pre></div><p><strong>Usage example:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=s>&#34;github.com/bwmarrin/snowflake&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Create a new node with worker ID (must be unique per instance)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>node</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>snowflake</span><span class=p>.</span><span class=nf>NewNode</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=c1>// Worker ID: 1 (range: 0-1023)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Generate a Snowflake ID</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>id</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>node</span><span class=p>.</span><span class=nf>Generate</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>id</span><span class=p>.</span><span class=nf>Int64</span><span class=p>())</span><span class=w>   </span><span class=c1>// e.g., 175928847299117063</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>id</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span><span class=w>  </span><span class=c1>// e.g., &#34;175928847299117063&#34;</span><span class=w>
</span></span></span></code></pre></div><p><strong>Alternative: sony/sonyflake</strong></p><p><a href=https://github.com/sony/sonyflake><code>github.com/sony/sonyflake</code></a> is another option that uses a different bit layout (39-bit time, 8-bit sequence, 16-bit machine ID), providing finer-grained machine ID space at the cost of time precision.</p><h2 id=migration-strategies>Migration Strategies</h2><h3 id=from-auto-increment>From Auto-Increment</h3><p><strong>Considerations:</strong></p><ul><li>Must provision worker ID allocation system</li><li>May need to widen integer columns (INT to BIGINT)</li><li>Application code changes for ID generation</li><li>Foreign key updates required</li></ul><p><strong>Recommended approach:</strong></p><ol><li>Add Snowflake ID column alongside auto-increment</li><li>Generate Snowflake IDs for existing rows</li><li>Update application to use Snowflake IDs for new records</li><li>Migrate foreign keys progressively</li><li>Eventually remove auto-increment column</li></ol><h3 id=from-uuid>From UUID</h3><p><strong>Considerations:</strong></p><ul><li>Significant storage reduction (16 â†’ 8 bytes)</li><li>Different data type (binary/string â†’ bigint)</li><li>Worker ID allocation system needed</li><li>May require application changes</li></ul><p><strong>Benefits:</strong></p><ul><li>50% storage reduction</li><li>Better performance</li><li>Numeric type easier for some use cases</li></ul><h2 id=summary>Summary</h2><p>Snowflake IDs represent an elegant solution for distributed systems:</p><p><strong>Key Strengths:</strong></p><ol><li><strong>Compact size:</strong> 8 bytes (half of UUID/ULID)</li><li><strong>Excellent performance:</strong> Sequential insertion, optimal for B-trees</li><li><strong>Time-ordered:</strong> Natural sorting and partitioning</li><li><strong>High throughput:</strong> Millions of IDs per second per worker</li><li><strong>URI-safe:</strong> Decimal integers require no encoding</li></ol><p><strong>Key Challenges:</strong></p><ol><li><strong>Worker ID management:</strong> Requires coordination (one-time)</li><li><strong>Auto-scaling complexity:</strong> Dynamic worker ID allocation needed</li><li><strong>Information leakage:</strong> Exposes timestamp and worker information</li><li><strong>Fixed limits:</strong> 1,024 workers without redesign</li></ol><p><strong>Best For:</strong></p><ul><li>High-scale distributed systems with predictable worker counts</li><li>Storage-constrained environments</li><li>Systems requiring time-ordered numeric IDs</li><li>Applications where 8-byte size matters</li></ul><p><strong>Consider Alternatives When:</strong></p><ul><li>Auto-scaling is critical and worker ID management is complex</li><li>Strict randomness required (use UUID v4)</li><li>Official standardization needed (use UUID v7)</li><li>More than 1,024 concurrent generators needed</li></ul><p><strong>Bottom Line:</strong>
For systems that can manage worker IDs and value storage efficiency, Snowflake IDs offer the best combination of size, performance, and distributed generation capabilities.</p></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/Zaba505/infra aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2024&ndash;2025
<span class=td-footer__authors>Zaba505 | <a href=https://creativecommons.org/licenses/by/4.0>CC BY 4.0</a> |</span></span><span class=td-footer__all_rights_reserved>All Rights Reserved</span></div></div></div></footer></div><script src=/infra/pr-preview/pr-626/js/main.min.eb40505784d893e4b5c8dbd67b59c353e735d847f4ffbfe9d6921dec08dbacba.js integrity="sha256-60BQV4TYk+S1yNvWe1nDU+c12Ef0/7/p1pId7AjbrLo=" crossorigin=anonymous></script><script defer src=/infra/pr-preview/pr-626/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/infra/pr-preview/pr-626/js/tabpane-persist.js></script></body></html>